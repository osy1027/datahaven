<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>í´ë˜ì‹ ë¯¸ë¡œ íƒˆì¶œ ê²Œì„</title>
  <style>
    body {
      background: #222;
      color: #fff;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 10px;
      text-align: center;
    }
    canvas {
      margin-top: 10px;
      border: 2px solid #eee;
      background: #111;
      image-rendering: pixelated;
      max-width: 100vw;
      max-height: 100vh;
    }
  </style>
</head>
<body>
  <h2>í´ë˜ì‹ ë¯¸ë¡œ íƒˆì¶œ ê²Œì„</h2>
  <p>ì´ë™: ë°©í–¥í‚¤ ë˜ëŠ” WASD</p>

  <canvas id="game"></canvas>

  <script>
    const tileSize = 32;

    // # = ë²½, . = ê¸¸, S = ì‹œì‘, E = ê°€ì§œ ì¶œêµ¬, R = ì§„ì§œ ì¶œêµ¬
    // í¬ê³  ê°€ì§€ ë§ì€ (31 x 31) ë¯¸ë¡œ
  const maze = [
"#####################",
"#S....#............E#",
"###.#.#.####.#.#####.#",
"#...#.#.#....#.....#.#",
"#.###.#.#.########.#.#",
"#.#...#.#....#.....#.#",
"#.#.###.####.#.#####.#",
"#.#.#.....#..#.......#",
"#.#.#.###.#.###.#.###.#",
"#.#.#.#.#.#.....#.#E.#",
"#.#.#.#.#.#######.#.#.#",
"#.#.#.#.#.......#...#.#",
"#E#.#.#.#########.#.#.#",
"#.....#.......#...#.#.#",
"###.#.#######.#.###.#.#",
"#...#.......#.#.....R.#",
"#####################"
];

    const rows = maze.length;
    const cols = maze[0].length;

    const canvas = document.getElementById("game");
    canvas.width = cols * tileSize;
    canvas.height = rows * tileSize;
    const ctx = canvas.getContext("2d");

    let player = {
      x: 0,
      y: 0,
      size: tileSize * 0.45
    };

    let start = { x: 0, y: 0 };
    const fakeExits = [];
    let realExit = null;
    const guards = [];

    // ë§µ íŒŒì‹±: ì‹œì‘ì , ì¶œêµ¬ë“¤ ì°¾ê¸°
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const ch = maze[r][c];
        const cx = (c + 0.5) * tileSize;
        const cy = (r + 0.5) * tileSize;

        if (ch === "S") {
          player.x = cx;
          player.y = cy;
          start.x = cx;
          start.y = cy;
        } else if (ch === "E") {
          fakeExits.push({ col: c, row: r, cx, cy });
        } else if (ch === "R") {
          realExit = { col: c, row: r, cx, cy };
        }
      }
    }

    // ê°€ì§œ ì¶œêµ¬ë§ˆë‹¤ ì (ê²½ë¹„) ìƒì„±
    // ì ì€ ì¶œêµ¬ ì• í†µë¡œì—ì„œ ì¢Œìš°ë¡œ ì™”ë‹¤ ê°”ë‹¤
    fakeExits.forEach(ex => {
      guards.push({
        exit: ex,
        active: false,
        x: ex.cx - tileSize,        // ì¶œêµ¬ ì™¼ìª½ì—ì„œ ì‹œì‘
        y: ex.cy,
        width: tileSize * 0.75,
        height: tileSize * 0.55,
        minX: ex.cx - tileSize,     // ì¢Œìš° ì´ë™ ë²”ìœ„
        maxX: ex.cx + tileSize,
        dir: 1,
        speed: 1.8,
        triggerRadius: tileSize * 1.3 // "ì§„ì§œ ê·¼ì²˜"ì—ì„œë§Œ ë“±ì¥
      });
    });

    const keys = {};
    window.addEventListener("keydown", e => (keys[e.key] = true));
    window.addEventListener("keyup", e => (keys[e.key] = false));

    function isWall(px, py) {
      const c = Math.floor(px / tileSize);
      const r = Math.floor(py / tileSize);
      if (c < 0 || c >= cols || r < 0 || r >= rows) return true;
      return maze[r][c] === "#";
    }

    function update() {
      const speed = 2.1;

      let vx =
        (keys.a || keys.ArrowLeft ? -1 : 0) +
        (keys.d || keys.ArrowRight ? 1 : 0);
      let vy =
        (keys.w || keys.ArrowUp ? -1 : 0) +
        (keys.s || keys.ArrowDown ? 1 : 0);

      // ëŒ€ê°ì„  ì†ë„ ë³´ì •
      if (vx !== 0 && vy !== 0) {
        vx *= Math.SQRT1_2;
        vy *= Math.SQRT1_2;
      }

      const prevX = player.x;
      const prevY = player.y;
      const half = player.size / 2;

      // X ì´ë™
      let nx = player.x + vx * speed;
      if (
        !isWall(nx - half, player.y - half) &&
        !isWall(nx + half, player.y - half) &&
        !isWall(nx - half, player.y + half) &&
        !isWall(nx + half, player.y + half)
      ) {
        player.x = nx;
      }

      // Y ì´ë™
      let ny = player.y + vy * speed;
      if (
        !isWall(player.x - half, ny - half) &&
        !isWall(player.x + half, ny - half) &&
        !isWall(player.x - half, ny + half) &&
        !isWall(player.x + half, ny + half)
      ) {
        player.y = ny;
      }

      // ê°€ì§œ ì¶œêµ¬ ê·¼ì²˜ì— "ì§„ì§œë¡œ ê°€ê¹Œì´" ê°”ì„ ë•Œë§Œ ì  í™œì„±í™”
      guards.forEach(g => {
        const dx = player.x - g.exit.cx;
        const dy = player.y - g.exit.cy;
        const d = Math.hypot(dx, dy);

        if (!g.active && d < g.triggerRadius) {
          g.active = true;
        }

        if (g.active) {
          g.x += g.dir * g.speed;
          if (g.x < g.minX) {
            g.x = g.minX;
            g.dir = 1;
          } else if (g.x > g.maxX) {
            g.x = g.maxX;
            g.dir = -1;
          }
        }
      });

      // ì ê³¼ ì¶©ëŒí•˜ë©´ ì´ë™ ë¬´íš¨
      for (const g of guards) {
        if (!g.active) continue;
        if (
          player.x + half > g.x &&
          player.x - half < g.x + g.width &&
          player.y + half > g.y &&
          player.y - half < g.y + g.height
        ) {
          player.x = prevX;
          player.y = prevY;
        }
      }

      // ê°€ì§œ ì¶œêµ¬ ë„ë‹¬ â†’ ì‹œì‘ì ìœ¼ë¡œ ë¦¬ì…‹
      fakeExits.forEach(ex => {
        const d = Math.hypot(player.x - ex.cx, player.y - ex.cy);
        if (d < tileSize * 0.35) {
          alert("ê°€ì§œ ì¶œêµ¬ì…ë‹ˆë‹¤! ë‹¤ì‹œ ì‹œì‘ì ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.");
          player.x = start.x;
          player.y = start.y;
        }
      });

      // ì§„ì§œ ì¶œêµ¬ ë„ë‹¬ â†’ í´ë¦¬ì–´
      if (realExit) {
        const d = Math.hypot(player.x - realExit.cx, player.y - realExit.cy);
        if (d < tileSize * 0.35) {
          alert("íƒˆì¶œ ì„±ê³µ! ğŸ‰");
          player.x = start.x;
          player.y = start.y;
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // íƒ€ì¼ ê·¸ë¦¬ê¸°
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const ch = maze[r][c];
          const x = c * tileSize;
          const y = r * tileSize;

          ctx.fillStyle = ch === "#" ? "#333" : "#111";
          ctx.fillRect(x, y, tileSize, tileSize);

          if (ch === "S") ctx.fillStyle = "#2ecc71";
          if (ch === "E") ctx.fillStyle = "#3498db";
          if (ch === "R") ctx.fillStyle = "#f1c40f";

          if ("SER".includes(ch)) {
            ctx.fillRect(x + 6, y + 6, tileSize - 12, tileSize - 12);
          }
        }
      }

      // ê²½ë¹„
      guards.forEach(g => {
        if (!g.active) return;
        ctx.fillStyle = "#e74c3c";
        ctx.fillRect(g.x, g.y, g.width, g.height);
      });

      // í”Œë ˆì´ì–´
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2);
      ctx.fill();
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
