<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>클래식 미로 탈출 게임</title>
  <style>
    body {
      background: url("/assets/mini_bg.png") no-repeat center center fixed;
      background-size: cover;
      color: #fff;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 10px;
      text-align: center;
    }

    canvas {
      margin-top: 10px;
      border: 2px solid #eee;
      image-rendering: pixelated;
      max-width: 100vw;
      max-height: 100vh;
    }

    /* layoutmaze keeps original size */
    .maze-layout {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: -2;
    }
    .maze-layout > img {
      width: 1250px; /* 유지 */
      height: auto;
      object-fit: contain;
      /* layout 기준: 그대로 둠 */
      transform: translateX(0px) translateY(0px);
    }

    /* maze.png + canvas 위치를 동일하게 유지하고 아래로 이동 */
    .maze-img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: -1;
    }
    .maze-img > img {
      width: 750px; /* 40% 축소(1250 × 0.6) */
      height: auto;
      object-fit: contain;
      transform: translateX(9px) translateY(-17px); /* 새 위치 */
    }
  </style>
</head>
<body>
  <h2>클래식 미로 탈출 게임</h2>
  <p>이동: 방향키 또는 WASD</p>

  <!-- Layout Maze (reference) -->
  <div class="maze-layout">
    <img src="/assets/layoutmaze.png" />
  </div>

  <!-- Maze background -->
  <div class="maze-img">
    <img src="/assets/maze.png" />
  </div>

  <canvas id="game"></canvas>

  <script>
    /* ====== 40% 축소 적용된 값 ====== */
    const tileSize = 19;       // 32 → 19
    const playerSize = 42;     // 70 → 42
    const hitboxSize = 12;     // 20 → 12
    const guardW = 24;         // 40 → 24
    const guardH = 24;         // 40 → 24
    const fakeExitSize = 30;   // 50 → 30
    const realExitSize = 30;   // 50 → 30

    /* 위치 보정 (maze.png와 맞춤) */
    const gameOffsetX = 9;
    const gameOffsetY = -17;

    /* ============================== */
    /* 이미지 로딩                     */
    /* ============================== */

    const playerImg = new Image();
    playerImg.src = "/assets/star.png";

    const guardImg = new Image();
    guardImg.src = "/assets/faceiconp.png";

    const realExitImg = new Image();
    realExitImg.src = "/assets/square.png";

    const fakeExitImages = [
      "/assets/circle.png",
      "/assets/triangle.png",
      "/assets/polygon.png",
      "/assets/square.png"
    ].map(src => { const i = new Image(); i.src = src; return i; });

    /* Exit offsets scaled */
    const fakeExitOffsets = [
      { x: -2, y: -5 },
      { x: 17, y: -8 },
      { x: 3,  y: 10 },
      { x: 3,  y: -18 }
    ];
    const realExitOffset = { x: -5, y: -4 };


    /* ============================== */
    /* MAZE MAP                       */
    /* ============================== */

    const maze = [
      "#####################",
      "#S....#............E#",
      "###.#.#.####.#.#####.#",
      "#...#.#.#....#.....#.#",
      "#.###.#.#.########.#.#",
      "#.#...#.#....#.....#.#",
      "#.#.###.####.#.#####.#",
      "#.#.#.....#..#.......#",
      "#.#.#.###.#.###.#.###.#",
      "#.#.#.#.#.#.....#.#E.#",
      "#.#.#.#.#.#######.#.#.#",
      "#.#.#.#.#.......#...#.#",
      "#E#.#.#.#########.#.#.#",
      "#.....#.......#...#.#.#",
      "###.#.#######.#.###.#.#",
      "#...#.......#.#.....R.#",
      "#####################"
    ];

    const rows = maze.length;
    const cols = maze[0].length;

    /* Canvas */
    const canvas = document.getElementById("game");
    canvas.width = cols * tileSize;
    canvas.height = rows * tileSize;
    canvas.style.transform = `translate(${gameOffsetX}px, ${gameOffsetY}px)`;

    const ctx = canvas.getContext("2d");

    let player = { x: 0, y: 0 };
    let start = { x: 0, y: 0 };
    const fakeExits = [];
    let realExit = null;
    const guards = [];


    /* Parse map for object positions */
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const ch = maze[r][c];
        const cx = (c + 0.5) * tileSize;
        const cy = (r + 0.5) * tileSize;

        if (ch === "S") {
          player.x = cx;
          player.y = cy;
          start.x = cx;
          start.y = cy;
        } else if (ch === "E") {
          fakeExits.push({ cx, cy, r, c });
        } else if (ch === "R") {
          realExit = { cx, cy };
        }
      }
    }


    /* Guards */
    fakeExits.forEach(ex => {
      guards.push({
        exit: ex,
        active: false,
        x: ex.cx - tileSize,
        y: ex.cy,
        width: tileSize * 0.75,
        height: tileSize * 0.55,
        minX: ex.cx - tileSize,
        maxX: ex.cx + tileSize,
        dir: 1,
        speed: 1.2,
        triggerRadius: tileSize * 4
      });
    });

    const keys = {};
    window.addEventListener("keydown", e => keys[e.key] = true);
    window.addEventListener("keyup", e => keys[e.key] = false);


    function isWall(px, py) {
      const c = Math.floor(px / tileSize);
      const r = Math.floor(py / tileSize);
      if (c < 0 || c >= cols || r < 0 || r >= rows) return true;
      return maze[r][c] === "#";
    }


    /* Game Update */
    let flickerFrame = 0;
    let playerVisible = true;

    function update() {
      const speed = 1.3;

      let vx =
        (keys.a || keys.ArrowLeft ? -1 : 0) +
        (keys.d || keys.ArrowRight ? 1 : 0);
      let vy =
        (keys.w || keys.ArrowUp ? -1 : 0) +
        (keys.s || keys.ArrowDown ? 1 : 0);

      if (vx !== 0 || vy !== 0) {
        flickerFrame++;
        if (flickerFrame % 6 === 0) {
          playerVisible = !playerVisible;
        }
      } else {
        playerVisible = true;
        flickerFrame = 0;
      }

      if (vx !== 0 && vy !== 0) {
        vx *= Math.SQRT1_2;
        vy *= Math.SQRT1_2;
      }

      const prevX = player.x;
      const prevY = player.y;
      const half = hitboxSize / 2;

      /* Move X */
      const nx = player.x + vx * speed;
      if (
        !isWall(nx - half, player.y - half) &&
        !isWall(nx + half, player.y - half) &&
        !isWall(nx - half, player.y + half) &&
        !isWall(nx + half, player.y + half)
      ) player.x = nx;

      /* Move Y */
      const ny = player.y + vy * speed;
      if (
        !isWall(player.x - half, ny - half) &&
        !isWall(player.x + half, ny - half) &&
        !isWall(player.x - half, ny + half) &&
        !isWall(player.x + half, ny + half)
      ) player.y = ny;


      /* Guard AI */
      guards.forEach(g => {
        const dx = player.x - g.exit.cx;
        const dy = player.y - g.exit.cy;
        const d = Math.hypot(dx, dy);
        if (!g.active && d < g.triggerRadius) g.active = true;

        if (g.active) {
          g.x += g.dir * g.speed;
          if (g.x < g.minX) { g.x = g.minX; g.dir = 1; }
          else if (g.x > g.maxX) { g.x = g.maxX; g.dir = -1; }
        }
      });


      /* Guard Collision */
      for (const g of guards) {
        if (!g.active) continue;
        if (
          player.x + half > g.x &&
          player.x - half < g.x + g.width &&
          player.y + half > g.y &&
          player.y - half < g.y + g.height
        ) {
          player.x = prevX;
          player.y = prevY;
        }
      }

      /* Fake Exit */
      fakeExits.forEach(ex => {
        const d = Math.hypot(player.x - ex.cx, player.y - ex.cy);
        if (d < tileSize * 0.35) {
          alert("가짜 출구입니다! 다시 시작합니다.");
          player.x = start.x;
          player.y = start.y;
        }
      });

      /* Real Exit */
      if (realExit) {
        const d = Math.hypot(player.x - realExit.cx, player.y - realExit.cy);
        if (d < tileSize * 0.35) {
          alert("탈출 성공!");
          player.x = start.x;
          player.y = start.y;
        }
      }
    }


    /* DRAW */
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      /* Exits */
      let eIndex = 0;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const ch = maze[r][c];
          const x = c * tileSize;
          const y = r * tileSize;

          if (ch === "E") {
            const img = fakeExitImages[eIndex % fakeExitImages.length];
            const offset = fakeExitOffsets[eIndex % fakeExitOffsets.length];

            ctx.drawImage(
              img,
              x + (tileSize - fakeExitSize) / 2 + offset.x,
              y + (tileSize - fakeExitSize) / 2 + offset.y,
              fakeExitSize,
              fakeExitSize
            );

            eIndex++;
          }

          if (ch === "R") {
            ctx.drawImage(
              realExitImg,
              x + (tileSize - realExitSize) / 2 + realExitOffset.x,
              y + (tileSize - realExitSize) / 2 + realExitOffset.y,
              realExitSize,
              realExitSize
            );
          }
        }
      }

      /* Guards */
      guards.forEach(g => {
        if (!g.active) return;
        ctx.drawImage(
          guardImg,
          g.x + (g.width - guardW) / 2,
          g.y + (g.height - guardH) / 2,
          guardW,
          guardH
        );
      });

      /* Player */
      if (playerVisible) {
        ctx.drawImage(
          playerImg,
          player.x - playerSize / 2,
          player.y - playerSize / 2,
          playerSize,
          playerSize
        );
      }
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
